## 1. 题目描述

N 位同学站成一排，音乐老师要请最少的同学出列，使得剩下的 K 位同学排成合唱队形。

设K*K*位同学从左到右依次编号为 1，2…，K ，他们的身高分别为T_1,T_2,…,T_K*T*1,*T*2,…,*T**K* ，若存在i(1\leq i\leq K)*i*(1≤*i*≤*K*) 使得T_1<T_2<......<T_{i-1}<T_i*T*1<*T*2<......<*T**i*−1<*T**i* 且 T_i>T_{i+1}>......>T_K*T**i*>*T**i*+1>......>*T**K*，则称这K*K*名同学排成了合唱队形。

通俗来说，能找到一个同学，他的两边的同学身高都依次严格降低的队形就是合唱队形。

例子：

123 124 125 123 121 是一个合唱队形

123 123 124 122不是合唱队形，因为前两名同学身高相等，不符合要求

123 122 121 122不是合唱队形，因为找不到一个同学，他的两侧同学身高递减。

你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。



示例1:

```
输入：
    8
    186 186 150 200 160 130 197 200

输出：4
说明：由于不允许改变队列元素的先后顺序，所以最终剩下的队列应该为186 200 160 130或150 200 160 130           
```



## 2. Solution

```python
# 动态规划
def lengthOfLIS(lst):
    dp = [1] * len(lst)
    for i in range(len(lst)):
        for j in range(i):
            if lst[i] > lst[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    return dp # 每人左边可以站的人数
 
while True:
    try:
        n, heights = int(input()), list(map(int, input().split()))
        # dp1:每人左边可以站的人数，dp2:每人右边可以站的人数
        dp1, dp2 = lengthOfLIS(heights), lengthOfLIS(heights[::-1])[::-1]
        # 这里要使用zip()，不然速度上可能过不去
        print(n - max(i+j-1 for i, j in zip(dp1, dp2)))
    except:
        break
```

